---
title: "R Notebook"
author: "Iryna Popovych, Sofiya Hevorhyan"
date: 'April 2019'
output: html_notebook
---
<style type="text/css">

body{ /* Normal  */
  font-size: 16px;
  color: black;
  font-family: "Times New Roman", Times, serif;
  background-image: url(https://png.pngtree.com/thumb_back/fw800/back_pic/04/21/71/295830892804e4c.jpg);
  background-position: center center;
  background-attachment: fixed;
  background-repeat: no-repeat;
  background-size: 100% 100%;
  }
h1.title {
  font-size: 34px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 28px;
  color: black;
}
h2 { /* Header 2 */
    font-size: 22px;
  font-family: "Times New Roman", Times, serif;
  color: darkpurple;
}
h3 { /* Header 3 */
  font-size: 18px;
  font-family: "Times New Roman", Times, serif;
  color: darkblue;
}
</style>

## 1 Dealing with data
### The idea of the structure of the data 
```{r}
library('stringr')
startup <- read.csv(file="./data/CAX_Startup_Data.csv", header=TRUE,as.is=T)
startup2 <- read.csv(file="./data2/CAX_Startup_Test.csv", header=TRUE,as.is=T)
head(startup)
```
### Functions for cleaning
```{r}
my.col.change.as.factor <- function(startup, col.name) {
  startup[,col.name] <- trimws(tolower(startup[,col.name]))
  vars <- unique(startup[,col.name])
  if (length(vars) == 2 || sum(is.na(vars)) == 1) {
    startup[,col.name] <- as.factor(startup[,col.name])
    return(startup)
  }
}
```
### Replacing common unknowns

We can see that some missing values are represented as “No Info” or are just “blanks”. So, the first step is to replace “No Info” and “blanks” with “NA” to get better sense of missing values in data.
However, it doesn't mean that there are no others nontypical strings in other columns. We will check this later

```{r}
startup[startup=="No Info"]<- NA 
startup[startup==""]<- NA 
startup[startup=="unknown amount"]<- NA 
```

### Retyping and renaming. Data convertation
```{r}
#Changing company_name (id) representation
names(startup)[1] <- "id"
startup$id <- as.numeric(str_replace(startup$id, 
                                     pattern="Company",
                                     replacement = ""))

#names
names(startup) <- tolower(names(startup))
my.names <- names(startup)

#Changing dependent company status
startup <- my.col.change.as.factor(startup, my.names[2])
```


Now, instead of doing all these transformation by hand, let's just try to automate this process.
After analyzing variables in this data, we consider 4 types of features that belong to class 'character'
1) the string itself (e.g 'description'), that should be so (deal with strings later)
2) the string that should be converted to 2- or multi-stage factor (e.g. company status which is 2-stage)
3) the string that should be converted to numetic data type (e.g. year of founding)
4) the string that should be converted to date

### Retyping to Date
```{r}
date.col <- c(13, 14)
date.col.names <- my.names[date.col]

startup$est..founding.date <- as.Date(startup$est..founding.date, "%m/%d/%Y") 
startup$last.funding.date <- as.Date(startup$last.funding.date, "%m/%d/%Y")
```

### Retyping col with numbers to numeric data type
As we can see, there are no warnings, so, all the data is in rows are numbers
```{r}
num.col<- c(3:5, 10:11,15,
            18:23,25,61,66,68:70,72,74,88,92,94:96,98,99,102:116) 
num.col.names <- my.names[num.col]

for(i in num.col)
  {
   startup[,i]<-round(as.numeric(startup[,i]), 4)
}
```
### Retyping col to two-stage factor
Get all the columns that are supposed to have only 2 types of answers (Y/N questions mostly)
```{r}
two.fact.col <- c(2, 12, 24, 27, 29:32,
                  34, 36, 38, 40:42, 44:53,
                  55, 58, 63:64, 77:78, 81:86, 89:91)

for(i in two.fact.col)
  {
   startup <- my.col.change.as.factor(startup, my.names[i])
}
```
### Retyping col to multi-stage factor
```{r}
# comment to 35 and 37
startup[,37] <- str_replace(startup[,37],
                            pattern="not applicable",
                            replacement="no")

multi.fact.col <- c(26, 28, 33, 35, 37, 39, 43, 54, 56,
                    57, 59, 60, 65, 67, 71, 73, 75, 76,
                    79, 80, 87, 93, 97, 100, 101)
ordered.levels <- c(26, 28, 43, 56, 57, 59, 67, 71, 73, 75,76, 79, 80, 87, 93)

my.replace <- function(startup, col.name, patt, replac) {
  startup[,col.name] <- str_replace(startup[,col.name], 
                                      pattern=patt,
                                      replacement = replac)
  return(startup)
}

change.as.multi.factor <- function(startup, col.name) {
  startup[,col.name] <- trimws(tolower(startup[,col.name]))
  
  
  if (col.name %in% ordered.levels) {
    startup <- my.replace(startup, col.name, "nothing", "none")
    startup <- my.replace(startup, col.name, "small", "low")
    startup <- my.replace(startup, col.name, "large", "high")
    #little trick
    startup <- my.replace(startup, col.name, "average", "close_average")
  }
  
  
  vars <- unique(startup[,col.name])
  startup[,col.name] <- as.factor(startup[,col.name])
  col.levels <- levels(startup[, col.name])
  if (length(col.levels) == 3 && ("few" %in% col.levels)) {
    col.levels <- c("none", "few", "many")
  } else if (length(col.levels) == 3 && "low" %in% col.levels) {
    col.levels <- c("low", "medium", "high")
  } else if (length(col.levels) == 4 && "low" %in% col.levels) {
    col.levels <- c("none", "low", "medium", "high")
  }
  startup[,col.name] <- factor(startup[,col.name],
                               levels = col.levels)
  return(startup)
}

# done: sort order in factors
for(i in multi.fact.col)
  {
  startup <- change.as.multi.factor(startup, i)
}

# todo: transform from factors to dummy
# model1 <- lm(employee.count ~ dependent.company.status + number.of.investors.in.seed, data=startup)
# library(caret)
# startup[,2] <- predict(dummyVars(~ dependent.company.status, data = startup), newdata = startup)[,2]
# model2 <- lm(employee.count ~ dependent.company.status + number.of.investors.in.seed, data=startup)
# summary(model1)
# summary(model2)
```
### Dealing with string
```{r}
char.col <- c(6:9, 16:17, 62)
```

### Missing values
For modelling, we need relevant data with not much missing values. Let's take a look on how they are distributred here:
```{r}
# Percent missing value for each variable
mis_val<-sapply(startup, function(x) sum(is.na(x)))
percent_mis<-as.data.frame(round((mis_val/nrow(startup))*100,1))

name<-row.names(percent_mis)
pcnt_mis_var<-cbind(name,percent_mis)
row.names(pcnt_mis_var)<-NULL
colnames(pcnt_mis_var)<-c("variable","Percent.Missing")
```

### Separating data
Any variable missing more than 50% should not be used in modeling as it can give false impression of relationship with dependent and can pollute the model. Being on conservative side generally we prefer to keep variable with less than 40% missing value only for treatment and anything above 40% missing values are to be used in testing only to give additional insights. 

```{r}
# keeping only variables with less than 40% missing
new_var<-as.character(pcnt_mis_var$variable[which(pcnt_mis_var$Percent.Missing<40)])
new_startup<-startup[new_var]

# separate data frame for more than 40% missing
other_var<-as.character(pcnt_mis_var$variable[which(pcnt_mis_var$Percent.Missing>=40)])
other_data<-startup[other_var]
```
We have seoarated 3 variables which are not suitable for further modelling.
```{r}
length(other_var)
```
Let's look how we reduced number of incomplete cases (rows which have missing values):
```{r}
sum(!complete.cases(startup)) - sum(!complete.cases(new_startup))
```
### Separate numerical and character data
It would be better if we separate out the numeric and character variables from data frame. It would help in performing operations going forward. 

```{r}
# Separate data frame for numeric variables
cnt_var <- c(num.col.names, date.col.names)
cnt_var <- cnt_var[!cnt_var %in% other_var]
cnt_df<-new_startup[cnt_var]

# separate data frame for character variables
var <- colnames(new_startup) %in% cnt_var 
char_df <- new_startup[!var]
```
## INDIVIDUAL VARIABLES - OUTLIERS

We need to remove ouliers or to subtract them with other values.

```{r}
library('matrixStats')

class(cnt_df$team.size.all.employees)

colQuantiles(data.matrix(cnt_df), probs = seq(0, 1, by= 0.2), na.rm = TRUE)
```
We create a function that replaces outliers with NA's using interquartile range. Outliers here are defined as observations that fall below Q1 − 1.5 IQR or above Q3 + 1.5 IQR.

```{r}
remove_outliers <- function(x, na.rm = TRUE, ...) {
  qnt <- quantile(x, probs=c(.25, .75), na.rm = na.rm, ...)
  H <- 1.5 * IQR(x, na.rm = na.rm)
  y <- x
  y[x < (qnt[1] - H)] <- NA
  y[x > (qnt[2] + H)] <- NA
  return(y)
}
```
Now we loop through all the columns witth numeric entries and eliminate ouliers using our function:

```{r}
for (n in colnames(cnt_df)){
  if (class(cnt_df[,n][1]) != "Date"){
     col <- cnt_df[,n]
     summary(col)
     col <- remove_outliers(col)
     summary(col)
     cnt_df[,n] <- col
  }
}
```
Take a look on quantiles again, some of the upper quantiles, like 'Team.size.all.employees' have changed significatly, from 5000 to 110, or 'Last.Funding.Amount' from 7.7e+07 to 1.4e+07  - our job with ouliers is done!
```{r}
colQuantiles(data.matrix(cnt_df), probs = seq(0, 1, by= 0.2), na.rm = TRUE)
```
## INDIVIDUAL VARIABLES - MISSING VALUES TREATMENT

As we can see, every variable in our dataset has NA's.

```{r}
sapply(cnt_df, function(x) sum(is.na(x))) 
```
Now we need to go back to the rows of the dataframe and impute missing values using K-nearest-neighbours algorithm. k-Nearest Neighbour Imputation is based on a variation of the Gower Distance for numerical, categorical, ordered and semi-continous variables.
```{r}
library('VIM')
library('zoo')

cnt_df[, 'Est..Founding.Date'] <- na.approx(cnt_df$Est..Founding.Date, na.rm = FALSE)
cnt_df[, 'Last.Funding.Date '] <- na.approx(cnt_df$Last.Funding.Date, na.rm = FALSE)

cnt <- kNN(cnt_df, k =10, imp_var = F)
```
No missing values, only missing dates left alive:
```{r}
sapply(cnt, function(x) sum(is.na(x)))
```

Take a look on quantiles again, some of the upper quantiles, like 'Team.size.all.employees' have changed significatly, from 5000 to 110, or 'Last.Funding.Amount' from 7.7e+07 to 1.4e+07  - our job with ouliers is done!

```{r}
colQuantiles(data.matrix(cnt_df), probs = seq(0, 1, by= 0.2), na.rm = TRUE)
```
## 2 Feature creation
```{r}
# change scale to log
cnt_df$last.funding.amount <- log(cnt_df$last.funding.amount)

# Create additional features like counting number of investors for company
char_df$investor.count<-length(strsplit(char_df$investors, "|",fixed=TRUE))
for (i in (1:length(char_df$investors))) {
  if(is.na(char_df$investors[i])==TRUE){
    char_df$investor.count[i]<- NA}
  else{
    lst<-strsplit(char_df$investors[i], "|", fixed=T)
    char_df$investor.count[i]<-length(lst[[1]])
  }
}

# lastfunding.amount vs. age of company ration
cnt_df$funging.agecomp.ratio <-
  cnt_df$last.funding.amount/cnt_df$age.of.company.in.years
```

## Graphics #1
```{r}
library(ggplot2)

# boxplot of employee count
boxplot(cnt_df$employee.count, main="box plot of employee count",
        ylab="Employee count")

# histogram with black outline, white fill and median line
ggplot(cnt_df, aes(x=employee.count))+
  geom_histogram(binwidth=5, colour="black", fill="white")+
  geom_vline(aes(xintercept=median(employee.count, na.rm=T)),
             color="red", linetype="dashed", size=1)+
  ggtitle("Histogram of Employee count")+
  xlab("Employee Count") +
  ylab("Frequency")+
  theme_light()
```
## Graphics #2
```{r}
# adding dependent variable to numeric data frame
cnt_df$dependent.company.status<-char_df$dependent.company.status

# box plot to see difference in mean of team size w.r.t two categories of dependent
ggplot(cnt_df, aes(x=dependent.company.status,y=team.size.all.employees,
                   fill=dependent.company.status)) +
  geom_boxplot()

# data preparation for bar chart
avg_emp<-aggregate(cnt_df$team.size.all.employees, 
                   by=list(cnt_df$dependent.company.status),
                   FUN=mean, na.rm=TRUE)
colnames(avg_emp)<-c("company.status","avg.employee.size")

# bar chart to check for difference in mean
ggplot(avg_emp, aes(x = company.status, y = avg.employee.size)) +
  geom_bar(stat = "identity")
```
## Graphics #3
```{r}

```

## Statistical tests
```{r}
# t-test for checking difference in mean
t.test(team.size.all.employees~dependent.company.status, data=cnt_df)

# tabulating data for chi-sq test
tab<- table(char_df$dependent.company.status,char_df$local.or.global.player)
# chi-sq test for categorical variable
chisq.test(tab)

# todo: F-test and more t-tests

```
### LDA
```{r}

```
### Variable Importance
```{r}
fit_glm <- glm(formula = dependent.company.status ~ ., data = cnt_df)

library(caret)
importance1 <- varImp(fit_glm)
#ranks features, the bigger oberall, the more var is important
head(importance1)

library(randomForest)
fit_rf = randomForest(dependent.company.status~., data=cnt_df)
# Create an importance based on mean decreasing gini
importance2 <- importance(fit_rf)
head(importance2)

# open in large window
varImpPlot(fit_rf)
```
### Variable Selection

```{r}
```
## Model Building